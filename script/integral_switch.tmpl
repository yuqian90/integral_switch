/*
 * integral_switch.h
 * Copyright (C) 2019  Qian Yu
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef INTEGRAL_SWITCH_H_
#define INTEGRAL_SWITCH_H_

#include <tuple>
#include <type_traits>

namespace integral_switch{

#if defined(__cpp_constexpr) && __cpp_constexpr >= 201304
#define USE_CPP_14_CONSTEXPR
#endif

#ifndef __has_attribute
#define __has_attribute(x) 0
#endif

#if __has_attribute(always_inline) || defined(__GNUC__)
#define INTEGRAL_SWITCH_ALWAYS_INLINE __attribute__((__always_inline__)) inline
#elif defined(_MSC_VER)
#define INTEGRAL_SWITCH_ALWAYS_INLINE __forceinline
#else
#define INTEGRAL_SWITCH_ALWAYS_INLINE inline
#endif


namespace detail{

    // Some helper utilities
    template <bool... Bs> struct bool_sequence {};

    template <bool... Is>
    using all = std::is_same<bool_sequence<true, Is...>, bool_sequence<Is..., true>>;

    template <typename... Ts> using first_t = typename std::tuple_element<0, std::tuple<Ts...>>::type;

    template<typename...>
    struct integral_switch_impl; // undefined

    template<>
    struct integral_switch_impl<>
    {
        template<typename Ret, typename Visitor, typename T>
        static INTEGRAL_SWITCH_ALWAYS_INLINE Ret dispatch(Visitor&&, T&&)
        {
            throw std::invalid_argument("value");
        }


        template<typename Ret, typename Visitor, typename T, typename U>
        #ifdef USE_CPP_14_CONSTEXPR
        static INTEGRAL_SWITCH_ALWAYS_INLINE constexpr Ret dispatch_nothrow(Visitor&&, T&&, U&& default_ret)
        #else
        static INTEGRAL_SWITCH_ALWAYS_INLINE Ret dispatch_nothrow(Visitor&&, T&&, U&& default_ret)
        #endif
        {
            return std::forward<U>(default_ret);
        }
    };

    {% for height in range(number + 1) -%}
    template<{{ ", ".join(formatRange(range(height + 1), "typename IHead{}")) }}>
    struct integral_switch_impl<{{ ", ".join(formatRange(range(height + 1), "IHead{}")) }}>
    {
        template<typename Ret, typename Visitor, typename T>
        static INTEGRAL_SWITCH_ALWAYS_INLINE Ret dispatch(Visitor&& visitor, T&& value)
        {
            switch(value)
            {
                {% for i in range(height + 1) -%}
                case {{ "IHead{}::value".format(i) }}: return visitor({{ "IHead{}".format(i) }}{});
                {% endfor -%}
                default: return integral_switch_impl<>::template dispatch<Ret>(std::forward<Visitor>(visitor), std::forward<T>(value));
            }
        }

        template<typename Ret, typename Visitor, typename T, typename U>
        #ifdef USE_CPP_14_CONSTEXPR
        static INTEGRAL_SWITCH_ALWAYS_INLINE constexpr Ret dispatch_nothrow(Visitor&& visitor, T&& value, U&& default_ret)
        #else
        static INTEGRAL_SWITCH_ALWAYS_INLINE Ret dispatch_nothrow(Visitor&& visitor, T&& value, U&& default_ret)
        #endif
        {
            switch(value)
            {
                {% for i in range(height + 1) -%}
                case {{ "IHead{}::value".format(i) }}: return visitor({{ "IHead{}".format(i) }}{});
                {% endfor -%}
                default: return integral_switch_impl<>::template dispatch_nothrow<Ret>(std::forward<Visitor>(visitor), std::forward<T>(value), std::forward<U>(default_ret));
            }
        }
    };

    {% endfor -%}

    template<{{ ", ".join(formatRange(range(number), "typename IHead{}")) }}, typename... ITail>
    struct integral_switch_impl<{{ ", ".join(formatRange(range(number), "IHead{}")) }}, ITail...>
    {
        template<typename Ret, typename Visitor, typename T>
        static INTEGRAL_SWITCH_ALWAYS_INLINE Ret dispatch(Visitor&& visitor, T&& value)
        {
            switch(value)
            {
                {% for i in range(number) -%}
                case {{ "IHead{}::value".format(i) }}: return visitor({{ "IHead{}".format(i) }}{});
                {% endfor -%}
                default: return integral_switch_impl<ITail...>::template dispatch<Ret>(std::forward<Visitor>(visitor), std::forward<T>(value));
            }
        }

        template<typename Ret, typename Visitor, typename T, typename U>
        #ifdef USE_CPP_14_CONSTEXPR
        static INTEGRAL_SWITCH_ALWAYS_INLINE constexpr Ret dispatch_nothrow(Visitor&& visitor, T&& value, U&& default_ret)
        #else
        static INTEGRAL_SWITCH_ALWAYS_INLINE Ret dispatch_nothrow(Visitor&& visitor, T&& value, U&& default_ret)
        #endif
        {
            switch(value)
            {
                {% for i in range(number) -%}
                case {{ "IHead{}::value".format(i) }}: return visitor({{ "IHead{}".format(i) }}{});
                {% endfor -%}
                default: return integral_switch_impl<ITail...>::template dispatch_nothrow<Ret>(std::forward<Visitor>(visitor), std::forward<T>(value), std::forward<U>(default_ret));
            }
        }
    };


}

template<typename T, T... v>
class integral_switch
{
    template <typename Visitor, typename U>
    using return_type_of = decltype(std::declval<Visitor>()(std::declval<U>()));

    template <typename Visitor>
    using return_type = return_type_of<Visitor, detail::first_t<std::integral_constant<T, v>...>>;

    template <typename Visitor> struct check_return_type {
        using expected_type = return_type<Visitor>;

        template <T u> using actual_type = return_type_of<Visitor, std::integral_constant<T, u>>;

        static constexpr bool check() {
            static_assert(detail::all<std::is_same<expected_type, actual_type<v>>::value...>::value,
                          "All return types must be equal");
            return true;
        }
    };

public:
    template<typename Visitor, typename U>
    static INTEGRAL_SWITCH_ALWAYS_INLINE return_type<Visitor> visit(Visitor&& visitor, U&& value)
    {
        check_return_type<Visitor>::check();
        return detail::integral_switch_impl<std::integral_constant<T, v>...>::template dispatch<return_type<Visitor>>(std::forward<Visitor>(visitor), std::forward<U>(value));
    }

    template<typename Visitor, typename U, typename R>
    #ifdef USE_CPP_14_CONSTEXPR
    static INTEGRAL_SWITCH_ALWAYS_INLINE constexpr return_type<Visitor> visit_nothrow(Visitor&& visitor, U&& value, R&& default_ret)
    #else
    static INTEGRAL_SWITCH_ALWAYS_INLINE return_type<Visitor> visit_nothrow(Visitor&& visitor, U&& value, R&& default_ret)
    #endif
    {
        check_return_type<Visitor>::check();
        return detail::integral_switch_impl<std::integral_constant<T, v>...>::template dispatch_nothrow<return_type<Visitor>>(std::forward<Visitor>(visitor), std::forward<U>(value), std::forward<R>(default_ret));
    }
};

}

#endif
